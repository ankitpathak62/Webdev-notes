import type { AutoEncryptionOptions, ConnectionExtraInfo, ConnectionInfo, ServerApi, ServiceProvider } from '@mongosh/service-provider-core';
import type { ApiEvent, ApiEventWithArguments, ConfigProvider, MongoshBus, ShellUserConfig } from '@mongosh/types';
import type ChangeStreamCursor from './change-stream-cursor';
import { Topologies } from './enums';
import type { AggregationCursor, Cursor, RunCommandCursor, Database, ShellResult } from './index';
import { Mongo, ShellApi } from './index';
import { InterruptFlag } from './interruptor';
import type { ShellBson } from './shell-bson';
export interface ShellCliOptions {
    nodb?: boolean;
}
export interface AutocompleteParameters {
    topology: () => Topologies | undefined;
    apiVersionInfo: () => Required<ServerApi> | undefined;
    connectionInfo: () => ConnectionExtraInfo | undefined;
    getCollectionCompletionsForCurrentDb: (collName: string) => Promise<string[]>;
    getDatabaseCompletions: (dbName: string) => Promise<string[]>;
}
export interface OnLoadResult {
    resolvedFilename: string;
    evaluate(): Promise<void>;
}
export interface EvaluationListener extends Partial<ConfigProvider<ShellUserConfig>> {
    onPrint?: (value: ShellResult[], type: 'print' | 'printjson') => Promise<void> | void;
    onPrompt?: (question: string, type: 'password' | 'yesno') => Promise<string> | string;
    onClearCommand?: () => Promise<void> | void;
    onExit?: (exitCode?: number) => Promise<never>;
    onLoad?: (filename: string) => Promise<OnLoadResult> | OnLoadResult;
    getCryptLibraryOptions?: () => Promise<AutoEncryptionOptions['extraOptions']>;
}
export interface ShellPlugin {
    transformError?: (err: Error) => Error;
}
export default class ShellInstanceState {
    currentCursor: Cursor | AggregationCursor | ChangeStreamCursor | RunCommandCursor | null;
    currentDb: Database;
    messageBus: MongoshBus;
    initialServiceProvider: ServiceProvider;
    private connectionInfoCache;
    context: any;
    mongos: Mongo[];
    shellApi: ShellApi;
    shellBson: ShellBson;
    cliOptions: ShellCliOptions;
    evaluationListener: EvaluationListener;
    displayBatchSizeFromDBQuery: number | undefined;
    isInteractive: boolean;
    apiCallDepth: number;
    private warningsShown;
    readonly interrupted: InterruptFlag;
    resumeMongosAfterInterrupt: Array<{
        mongo: Mongo;
        resume: (() => Promise<void>) | null;
    }> | undefined;
    private plugins;
    private alreadyTransformedErrors;
    private preFetchCollectionAndDatabaseNames;
    constructor(initialServiceProvider: ServiceProvider, messageBus?: any, cliOptions?: ShellCliOptions);
    fetchConnectionInfo(): Promise<ConnectionInfo | undefined>;
    cachedConnectionInfo(): ConnectionInfo | undefined;
    close(force: boolean): Promise<void>;
    setPreFetchCollectionAndDatabaseNames(value: boolean): void;
    setDbFunc(newDb: any): Database;
    setCtx(contextObject: any): void;
    get currentServiceProvider(): ServiceProvider;
    emitApiCallWithArgs(event: ApiEventWithArguments): void;
    emitApiCall(event: Omit<ApiEvent, 'callDepth'>): void;
    setEvaluationListener(listener: EvaluationListener): void;
    getAutocompleteParameters(): AutocompleteParameters;
    apiVersionInfo(): Required<ServerApi> | undefined;
    onInterruptExecution(): Promise<boolean>;
    onResumeExecution(): Promise<boolean>;
    getDefaultPrompt(): Promise<string>;
    private getDefaultPromptPrefix;
    private getTopologySpecificPrompt;
    private getTopologySinglePrompt;
    registerPlugin(plugin: ShellPlugin): void;
    transformError(err: any): any;
    printDeprecationWarning(message: string): Promise<void>;
    printWarning(message: string): Promise<void>;
}
