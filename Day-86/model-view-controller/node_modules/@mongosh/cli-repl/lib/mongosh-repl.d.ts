/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import type { AutoEncryptionOptions, ServiceProvider } from '@mongosh/service-provider-core';
import type { EvaluationListener, OnLoadResult, ShellCliOptions } from '@mongosh/shell-api';
import { ShellInstanceState } from '@mongosh/shell-api';
import type { ShellResult } from '@mongosh/shell-evaluator';
import { ShellEvaluator } from '@mongosh/shell-evaluator';
import type { ConfigProvider, MongoshBus } from '@mongosh/types';
import { CliUserConfig } from '@mongosh/types';
import type { ReplOptions, REPLServer } from 'repl';
import type { Readable, Writable } from 'stream';
import * as asyncRepl from './async-repl';
import type { StyleDefinition } from './clr';
import { LineByLineInput } from './line-by-line-input';
import type { FormatOptions } from './format-output';
import type { Context } from 'vm';
export type MongoshCliOptions = ShellCliOptions & {
    quiet?: boolean;
    jsContext?: JSContext;
    exposeAsyncRewriter?: boolean;
};
export type MongoshIOProvider = Omit<ConfigProvider<CliUserConfig>, 'validateConfig' | 'resetConfig'> & {
    getHistoryFilePath(): string;
    exit(code?: number): Promise<never>;
    readFileUTF8(filename: string): Promise<{
        contents: string;
        absolutePath: string;
    }>;
    getCryptLibraryOptions(): Promise<AutoEncryptionOptions['extraOptions']>;
    bugReportErrorMessageInfo?(): string | undefined;
};
export type JSContext = 'repl' | 'plain-vm';
export type MongoshNodeReplOptions = {
    input: Readable;
    output: Writable;
    bus: MongoshBus;
    ioProvider: MongoshIOProvider;
    shellCliOptions?: Partial<MongoshCliOptions>;
    nodeReplOptions?: Partial<ReplOptions>;
};
export type InitializationToken = {
    __initialized: 'yes';
};
type MongoshRuntimeState = {
    shellEvaluator: ShellEvaluator<any>;
    instanceState: ShellInstanceState;
    repl: REPLServer | null;
    context: Context;
    console: Console;
};
declare class MongoshNodeRepl implements EvaluationListener {
    _runtimeState: MongoshRuntimeState | null;
    input: Readable;
    lineByLineInput: LineByLineInput;
    output: Writable;
    bus: MongoshBus;
    nodeReplOptions: Partial<ReplOptions>;
    shellCliOptions: Partial<MongoshCliOptions>;
    ioProvider: MongoshIOProvider;
    onClearCommand?: EvaluationListener['onClearCommand'];
    insideAutoCompleteOrGetPrompt: boolean;
    inspectCompact: number | boolean;
    inspectDepth: number;
    started: boolean;
    showStackTraces: boolean;
    loadNestingLevel: number;
    redactHistory: 'keep' | 'remove' | 'remove-redact';
    rawValueToShellResult: WeakMap<any, ShellResult>;
    constructor(options: MongoshNodeReplOptions);
    setIsInteractive(value: boolean): void;
    get isInteractive(): boolean;
    initialize(serviceProvider: ServiceProvider, moreRecentMongoshVersion?: string | null): Promise<InitializationToken>;
    private finishInitializingNodeRepl;
    startRepl(_initializationToken: InitializationToken): Promise<void>;
    greet(mongodVersion: string, moreRecentMongoshVersion?: string | null): Promise<void>;
    printBasicConnectivityWarning(instanceState: ShellInstanceState): Promise<void>;
    eval(originalEval: asyncRepl.OriginalEvalFunction, input: string, context: any, filename: string): Promise<any>;
    onLoad(filename: string): Promise<OnLoadResult>;
    loadExternalFile(filename: string): Promise<void>;
    loadExternalCode(input: string, filename: string): Promise<ShellResult>;
    onAsyncSigint(): Promise<boolean>;
    writer(result: any): string;
    formatShellResult(result: {
        type: null | string;
        printable: any;
    }, extraFormatOptions?: Partial<FormatOptions>): string;
    onPrint(values: ShellResult[], type: 'print' | 'printjson'): void;
    onPrompt(question: string, type: 'password' | 'yesno'): Promise<string>;
    formatOutput(value: {
        value: any;
        type?: string | null;
    }, extraFormatOptions?: Partial<FormatOptions>): string;
    formatError(value: Error): string;
    clr(text: string, style: StyleDefinition): string;
    getFormatOptions(): FormatOptions;
    runtimeState(): MongoshRuntimeState;
    close(): Promise<void>;
    onExit(exitCode?: number): Promise<never>;
    getConfig<K extends keyof CliUserConfig>(key: K): Promise<CliUserConfig[K] | undefined>;
    setConfig<K extends keyof CliUserConfig>(key: K, value: CliUserConfig[K]): Promise<'success' | 'ignored'>;
    resetConfig<K extends keyof CliUserConfig>(key: K): Promise<'success' | 'ignored'>;
    validateConfig<K extends keyof CliUserConfig>(key: K, value: CliUserConfig[K]): Promise<string | null>;
    listConfigOptions(): Promise<string[]> | string[] | undefined;
    getCryptLibraryOptions(): Promise<AutoEncryptionOptions['extraOptions']>;
    private getShellPrompt;
    jsContext(): JSContext;
}
export default MongoshNodeRepl;
